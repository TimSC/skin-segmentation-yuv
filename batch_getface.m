
%Title: batch_getface(col_space,display_output,scdm_files,in_files,out_files)
%Author: Timothy Sheerman-Chase
%Date: 8 October 2000
%Description: This actually takes a picture and tries to isolate the skin pixels. Uses the histograms
%generated by the other programs.
%Dependencies: Existing SCDM files, pictoyuv.m
%Arguments:
%col_space - This defines what colour space the program works in. (1 is YUV) (2 to HSV)
%display_output - If this is 1 then the program displays human faces during this function
%scdm_files - This is the path to the scdm histogram files
%in_files - This is the path to the unmodifed picture files containing faces
%out_files - This is the path to the output files - (the probability distributions are saved here)

function batch_getface(col_space,display_output,use_intensity_hist,scdm_files,Files_to_open,Files_to_save,transform_face,file_root)

if nargin<1, error('Not enough inputs.'); end
if nargin==1
   scdm_files = 'C:/My Documents/matlab/pic_out/scdm';
end

if transform_face > 0,
   [transform_type,Parameters,StrPar,inverse] = choose_transform(file_root);
else
   transform_type = 0;
end

SCDM_number = input('\nDetect Using Which SCDM? (eg 009)','s');
detect_performance = input('\nDetect only faces for performance measure? (0/1)','s');

	fprintf('\nReading SCDM data');
   
   %Reads in the files and SCDM for use later
	in_file_name = sprintf('%sWorkspace\\scdm%s.png',file_root,SCDM_number);
	SCDM_data = imread(in_file_name,'png'); %reads the colour histogram
	SCDM_data = double(SCDM_data(:,:));
	SCDM_size = size(SCDM_data);
	SCDM_data_resize = reshape(SCDM_data,SCDM_size(1)*SCDM_size(2),1);

	skin_prob_max=0; %This is a normalisation maximum
   
   fprintf('\nLooking for intensity data file \n%sWorkspace\\intensity%s.dat',file_root,SCDM_number)
	in_file_name = sprintf('%sWorkspace\\intensity%s.dat',file_root,SCDM_number);
	in_file = fopen(in_file_name,'r');
	SCDM_y = fread(in_file, inf, 'float32'); %Reads intensity distribution
	fclose(in_file);
   
%%%%%%%%%%%%%%%%%%%%%
%This is the main file open loop
[null,number_of_files]=size(Files_to_open);
for l=1:number_of_files
   fid=0;

	%s=sprintf(in_files,l); %Edit as needed

   fid=fopen(getfield(Files_to_open,{l},'name'),'r');
   if detect_performance == '1',
      precise_mask_name = getfield(Files_to_open,{l},'name');
      [null,strlen] = size (precise_mask_name);
         if strlen > 13,
         	precise_mask_name(strlen-12) = 'F';
         end
      fid2 = 0;
      fid2=fopen(precise_mask_name,'r');
      if fid2 < 1, fid = 0;end;
      if fid2 > 0, fclose(fid2); end;
   end
   
   if fid>1 % This check if the file exists
      fclose(fid);
      fprintf('\nFound file: %s',getfield(Files_to_open,{l},'name'));
   
	clear Skin_mask_pic;
	clear Skin_pic;

	time_keeper=cputime; %Start timer (to see how long program takes)

	fprintf('\nLoading Picture:')

	Pic = imread(getfield(Files_to_open,{l},'name')); %Edit as needed
	size_Pic = size(Pic);
   
   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   % This converts the picture into the colour space desired.
   
   if col_space == 1
      	if transform_type == 2,
      		Pic= imresize(Pic,[200,200]);
            size_Pic = size(Pic);
         end;
         
            Pic_converted = pictoyuv_opt(Pic);%Converts to yuv space
            
            if transform_face > 0,
               Pic_converted=perform_transform(Pic_converted,transform_type,...
                  Parameters,StrPar,file_root,inverse);
            end
            
        	elseif col_space == 2 %HSV
         	Pic_temp = double(Pic) ./ 255;
				Pic_converted = floor(rgb2hsv(Pic_temp) .* 255);
            %imagesc(Pic_out);
         elseif col_space == 3 %Chromatic
    	 		Pic_converted = Pic;
     			Pic_converted(:,:,3) = (double(Pic(:,:,1)) + double(Pic(:,:,2)) + double(Pic(:,:,3))) ./ 3;
         %Black_Map = 1 - sign(double( Pic_rgb(:,:,3) )-0).^2;
         %Pic_out(:,:,3) = double(Pic_out(:,:,3)) + Black_Map;
    			Pic_converted(:,:,1) = 255 .* double(Pic(:,:,1)) ./ (3 .* double(Pic_converted(:,:,3)) );
     			Pic_converted(:,:,2) = 255 .* double(Pic(:,:,2)) ./ (3 .* double(Pic_converted(:,:,3)) );
    	   elseif col_space == 4
         	Pic_temp = double(Pic) ./ 255;
				Pic_converted = rgb2ntsc(Pic_temp);
            Pic_converted(:,:,2) = Pic_converted(:,:,2)+ .5;
            Pic_converted(:,:,3) = Pic_converted(:,:,3)+ .6;
            figure(3);imagesc(Pic_converted);
      	elseif col_space == 5
      	  	Pic_in = double(Pic) ./ 255;
				Pic_converted = rgb2ycbcr(Pic_in);
      	end
         
         %End of colour space conversion
         %%%%%%%%%%%%%%%
         
         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
         %The next section splits the three component colour space into a two
         % component colour array and an intensity array. This makes the later
         % parts of the program similar. For example YUV has the first component
         % as intensity while HSV has the last component as intensity. This just
         % makes all things equal.
         
    	  if col_space == 1 %Pic is yuv
     		   col_data=zeros(size_Pic(1),size_Pic(2),2);
       	   col_data(:,:,1)= Pic_converted(:,:,2);
         	col_data(:,:,2)= Pic_converted(:,:,3);
         	intensity_data=zeros(size_Pic(1),size_Pic(2));
         	intensity_data(:,:)= Pic_converted(:,:,1);
         	histogram_max=140;
      	elseif col_space == 2  | (col_space == 3)%Pic is hsv or chromatic
         	col_data=zeros(size_Pic(1),size_Pic(2),2);
         	col_data(:,:,1)= Pic_converted(:,:,1);
         	col_data(:,:,2)= Pic_converted(:,:,2);
         	intensity_data=zeros(size_Pic(1),size_Pic(2));
         	intensity_data(:,:)= Pic_converted(:,:,3);
            histogram_max=256;
    	  elseif (col_space == 4) | (col_space == 5) 
     		   col_data=zeros(size_Pic(1),size_Pic(2),2);
            col_data(:,:,1)= Pic_converted(:,:,2);
            col_data(:,:,2)= Pic_converted(:,:,3);
            intensity_data=zeros(size_Pic(1),size_Pic(2));
            intensity_data(:,:)= Pic_converted(:,:,1);
            histogram_max=256;            
      	end

size_SCDM_y = size(SCDM_y);

   %%%%%%%%%%%%
   %This section finds the face now the data has been read in to arrays.
   
	disp('Creating Face Mask'); 

	      Y=  double(intensity_data(:,:));
         UfVf_data= double(col_data(:,:,2))*SCDM_size(2) + double(col_data(:,:,1)) + 1;

      	%This is the third time I have used this trick:
      	%Include two numbers in one - the u and v numbers and combined in this line.
         
         if (use_intensity_hist == 1)
         Skin_pic = SCDM_data_resize(UfVf_data) .* SCDM_y(Y+1) ./ 255^2; %A little bit of fuzzy logic
   	   %This compares each pixel to the histograms to see if
         %the pixel looks like past skin pixels
     		else
         Skin_pic = SCDM_data_resize(UfVf_data) ./ 255; %A little bit of fuzzy logic
         end
         
	skin_prob_max = max(max(Skin_pic(:,:)));
	fprintf('\nSkin Probability Max = ');
	disp(skin_prob_max);
   
   if nargin>=4
      imwrite(Skin_pic,getfield(Files_to_save,{l},'name'),'png');
   end
   %By this point the probability of each pixel being skin is known.
   %%%%%%%%%%%%%%%%%%%%%%%%%
   
   	 fprintf('\nFound probabilities in (sec):');
       disp(cputime - time_keeper);
   
   %This thresholds the probability to simply have a mask area
if (nargin == 1 ) | (display_output == 1)

	if col_space == 1 %Pic is yuv
	   Skin_pic_threshold = sign(sign(Skin_pic-0.05)+1); %Threshold at a certain level.
	elseif col_space == 2 %Pic is hsv
      Skin_pic_threshold = sign(sign(Skin_pic-0.006)+1); %Threshold at a certain level.
   elseif col_space >= 3 %Pic is hsv
 	  Skin_pic_threshold = sign(sign(Skin_pic-0.006)+1); %Threshold at a certain level.
	end

	skin_prob_max = max(max(Skin_pic(:,:)));

	%Takes the original picture and uses the skin colour likeness to filter it.
	%This _should_ isolate the skin in its original appearance.
 	  Skin_mask_pic(:,:,1)= uint8(Skin_pic_threshold(:,:) .* double(Pic(:,:,1)));
  	  Skin_mask_pic(:,:,2)= uint8(Skin_pic_threshold(:,:) .* double(Pic(:,:,2)));
 	  Skin_mask_pic(:,:,3)= uint8(Skin_pic_threshold(:,:) .* double(Pic(:,:,3)));

	figure(4); imagesc(Skin_mask_pic);
	figure(5); imagesc(Skin_pic); colorbar;
      
    end %End of if nargin < 4
    
	    disp('Time taken in processing:');
       disp(cputime - time_keeper);
       
    if (nargin == 1 ) | (display_output == 1)
       disp('Hit any key');
       pause
    end
       
end %End of file exist = true loop
end %End of file opener loop
